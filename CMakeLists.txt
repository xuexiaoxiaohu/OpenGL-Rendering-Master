#set cmake version number
cmake_minimum_required(VERSION 3.4.0)

#set project name
project(OpenGL-Rendering-Project)
SET(CMAKE_BUILD_TYPE "Release")
set(CMAKE_INCLUDE_CURRENT_DIR ON) 
# Enable C++17
set(CMAKE_CXX_STANDARD 17)

# NDI
if(NOT NDI_ROOT)
        set(NDI_ROOT "" CACHE PATH "NDI root path")
endif()
if(NDI_ROOT)
	set(NDI_LIB_DIR ${NDI_ROOT}/lib/)
    set(NDI_BIN_DIR ${NDI_ROOT}/bin/)
    file(GLOB NDI_LIB_FILES ${NDI_ROOT}/lib/*.lib)
    file(GLOB NDI_BIN_FILES ${NDI_ROOT}/bin/*.dll)
    set(NDI_INC_DIR ${NDI_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without NDI")
endif(NDI_ROOT)
include_directories(${NDI_INC_DIR})

# Reconstrucion
if(NOT RECONSTRUCTION_ROOT)
        set(RECONSTRUCTION_ROOT "" CACHE PATH "Reconstrucion root path")
endif()
if(RECONSTRUCTION_ROOT)
	set(RECONSTRUCTION_LIB_DIR ${RECONSTRUCTION_ROOT}/lib/)
    set(RECONSTRUCTION_BIN_DIR ${RECONSTRUCTION_ROOT}/bin/)
    file(GLOB RECONSTRUCTION_LIB_FILES ${RECONSTRUCTION_ROOT}/lib/*.lib)
    file(GLOB RECONSTRUCTION_BIN_FILES ${RECONSTRUCTION_ROOT}/bin/*.dll)
    set(RECONSTRUCTION_INC_DIR ${RECONSTRUCTION_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without Reconstrucion")
endif(RECONSTRUCTION_ROOT)
include_directories(${RECONSTRUCTION_INC_DIR})

# Glut
if(NOT GLUT_ROOT)
    set(GLUT_ROOT "" CACHE PATH "Glut glut root")
endif()
if(GLUT_ROOT)
	set(GLUT_LIB_DIR ${GLUT_ROOT}/lib/)
    set(GLUT_BIN_DIR ${GLUT_ROOT}/bin/)
    file(GLOB GLUT_LIB_FILES ${GLUT_ROOT}/lib/*.lib)
    file(GLOB GLUT_BIN_FILES ${GLUT_ROOT}/bin/*.dll)
    set(GLUT_INC_DIR ${GLUT_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without Glut")
endif(GLUT_ROOT)
include_directories(${GLUT_INC_DIR})

# OpenMesh
if(NOT OPENMESH_ROOT)
    set(OPENMESH_ROOT "" CACHE PATH "OpenMesh root")
endif()
if(OPENMESH_ROOT)
	set(OPENMESH_LIB_DIR ${OPENMESH_ROOT}/lib/)
    set(OPENMESH_BIN_DIR ${OPENMESH_ROOT}/bin/)
    file(GLOB OPENMESH_LIB_FILES ${OPENMESH_ROOT}/lib/*.lib)
    file(GLOB OPENMESH_BIN_FILES ${OPENMESH_ROOT}/bin/*.dll)
    set(OPENMESH_INC_DIR ${OPENMESH_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without OpenMesh")
endif(OPENMESH_ROOT)
include_directories(${OPENMESH_INC_DIR})

# PCL
if(NOT PCL_ROOT)
    set(PCL_ROOT "" CACHE PATH "PCL root")
endif()
if(PCL_ROOT)
	set(PCL_LIB_DIR ${PCL_ROOT}/lib/)
    set(PCL_BIN_DIR ${PCL_ROOT}/bin/)
    file(GLOB PCL_LIB_FILES ${PCL_ROOT}/lib/*.lib)
    file(GLOB PCL_BIN_FILES ${PCL_ROOT}/bin/*.dll)
    set(PCL_INC_DIR ${PCL_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without PCL")
endif(PCL_ROOT)
include_directories(${PCL_INC_DIR})

# Boost
if(NOT BOOST_ROOT)
    set(BOOST_ROOT "" CACHE PATH "Boost root")
endif()
if(BOOST_ROOT)
	set(BOOST_LIB_DIR ${BOOST_ROOT}/lib/)
    set(BOOST_BIN_DIR ${BOOST_ROOT}/bin/)
    file(GLOB BOOST_LIB_FILES ${BOOST_ROOT}/lib/*.lib)
    file(GLOB BOOST_BIN_FILES ${BOOST_ROOT}/bin/*.dll)
    set(BOOST_INC_DIR ${BOOST_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without Boost")
endif(BOOST_ROOT)
include_directories(${BOOST_INC_DIR})

# Eigen
if(NOT EIGEN_ROOT)
    set(EIGEN_ROOT "" CACHE PATH "Eigen root")
endif()
if(EIGEN_ROOT)
	set(EIGEN_LIB_DIR ${EIGEN_ROOT}/lib/)
    set(EIGEN_BIN_DIR ${EIGEN_ROOT}/bin/)
    file(GLOB EIGEN_LIB_FILES ${EIGEN_ROOT}/lib/*.lib)
    file(GLOB EIGEN_BIN_FILES ${EIGEN_ROOT}/bin/*.dll)
    set(EIGEN_INC_DIR ${EIGEN_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without Eigen")
endif(EIGEN_ROOT)
include_directories(${EIGEN_INC_DIR})

# FLANN
if(NOT FLANN_ROOT)
    set(FLANN_ROOT "" CACHE PATH "FLANN root")
endif()
if(FLANN_ROOT)
	set(FLANN_LIB_DIR ${FLANN_ROOT}/lib/)
    set(FLANN_BIN_DIR ${FLANN_ROOT}/bin/)
    file(GLOB FLANN_LIB_FILES ${FLANN_ROOT}/lib/*.lib)
    file(GLOB FLANN_BIN_FILES ${FLANN_ROOT}/bin/*.dll)
    set(FLANN_INC_DIR ${FLANN_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without FLANN")
endif(FLANN_ROOT)
include_directories(${FLANN_INC_DIR})

# VTK
if(NOT VTK_ROOT)
    set(VTK_ROOT "" CACHE PATH "VTK root")
endif()
if(VTK_ROOT)
	set(VTK_LIB_DIR ${VTK_ROOT}/lib/)
    set(VTK_BIN_DIR ${VTK_ROOT}/bin/)
    file(GLOB VTK_LIB_FILES ${VTK_ROOT}/lib/*.lib)
    file(GLOB VTK_BIN_FILES ${VTK_ROOT}/bin/*.dll)
    set(VTK_INC_DIR ${VTK_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without VTK")
endif(VTK_ROOT)
include_directories(${VTK_INC_DIR})

# VMTK
if(NOT VMTK_ROOT)
    set(VMTK_ROOT "" CACHE PATH "VMTK root")
endif()
if(VMTK_ROOT)
	set(VMTK_LIB_DIR ${VMTK_ROOT}/lib/)
    set(VMTK_BIN_DIR ${VMTK_ROOT}/bin/)
    file(GLOB VMTK_LIB_FILES ${VMTK_ROOT}/lib/*.lib)
    file(GLOB VMTK_BIN_FILES ${VMTK_ROOT}/bin/*.dll)
    set(VMTK_INC_DIR ${VMTK_ROOT}/include/)
else()
    message(FATAL_ERROR "can not generate without VMTK")
endif(VMTK_ROOT)
include_directories(${VMTK_INC_DIR})

# QT
set(CMAKE_AUTOMOC ON) 
find_package(Qt5Widgets)  
find_package(Qt5Core)
find_package(Qt5Gui)
find_package(Qt5OpenGL)
find_package(Qt5OpenGLExtensions)
file(GLOB SRC_FILES "./*.cpp" "./*.cxx" "./*.c") 
file(GLOB HEAD_FILES "./*.h" "./*.hpp" "./*.hxx") 
file(GLOB UI_FILES "./UI/*.ui") 
file(GLOB SHADER_FILES "./Shader/*.frag" "./Shader/*.vert") 

qt5_wrap_ui(WRAP_FILES ${UI_FILES})
qt5_add_resources(QRC_FILES ${RCC_FILES})

source_group("Ui" FILES ${UI_FILES})
source_group("Source" FILES ${SRC_FILES})
source_group("Header" FILES ${HEAD_FILES})
source_group("Shader" FILES ${SHADER_FILES})

add_definitions(-w)
add_executable(${PROJECT_NAME} ${SRC_FILES} ${HEAD_FILES} ${QRC_FILES} ${WRAP_FILES} ${SHADER_FILES})

target_link_libraries(${PROJECT_NAME} Qt5::Widgets Qt5::Core Qt5::Gui Qt5::OpenGL Qt5::OpenGLExtensions)
target_link_libraries (${PROJECT_NAME} ${NDI_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${PCL_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${BOOST_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${EIGEN_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${FLANN_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${VTK_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${VMTK_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${RECONSTRUCTION_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${GLUT_LIB_FILES})
target_link_libraries (${PROJECT_NAME} ${OPENMESH_LIB_FILES})

#copy file from source dirtory to binaray dirtory
file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/Data DESTINATION ${PROJECT_BINARY_DIR}/Release)
file(COPY ${CMAKE_CURRENT_SOURCE_DIR}/Shader DESTINATION ${PROJECT_BINARY_DIR}/Release)

# add debug information
if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
    add_definitions(-DAF_CLASSARRANGE_EXPORTS)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wl,-Bsymbolic")
    set(CMAKE_CXX_FLAGS_DEBUG "$ENV{CXXFLAGS} -O0 -Wall -g -ggdb")
    set(CMAKE_CXX_FLAGS_RELEASE "$ENV{CXXFLAGS} -g -O2 -Wall")
    add_compile_options(-Wall -Wextra -Wpedantic -fPIC -fvisibility=hidden)
    add_definitions(-D_GLIBCXX_USE_CXX11_ABI=0)
else()
    add_definitions(-D_CRT_SECURE_NO_WARNINGS -DAF_CLASSARRANGE_EXPORTS)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /utf-8")
	set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} /Zi")
    set(CMAKE_EXE_LINKER_FLAGS_RELEASE "${CMAKE_EXE_LINKER_FLAGS_RELEASE} /DEBUG:FULL /OPT:REF /OPT:ICF")
    set(CMAKE_SHARED_LINKER_FLAGS_RELEASE "${CMAKE_SHARED_LINKER_FLAGS_RELEASE} /DEBUG:FULL /OPT:REF /OPT:ICF")
endif()

set(HEADERS DataProcessing.h)

set(SOURCES DataProcessing.cpp)

add_library(DataProcessing ${SOURCES} ${HEADERS})
target_link_libraries(DataProcessing Qt5::Widgets Qt5::Core Qt5::Gui Qt5::OpenGL Qt5::OpenGLExtensions)